\documentclass[12pt, oneside]{article}

%Codificación e idioma
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

% Url
\usepackage{url}

% Graphics
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.png,.jpg}

\usepackage{wrapfig}

%Resaltado de sintaxis
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\definecolor{red}{rgb}{0.6,0,0} % strings
\definecolor{green}{rgb}{0.25,0.5,0.35} % comments
\definecolor{purple}{rgb}{0.5,0,0.35} % keywords
\definecolor{blue}{rgb}{0.25,0.35,0.75} % doc

\usepackage{listings}
\lstset {
	frame				=	Ltb,
    framerule			=	0pt,
    aboveskip			=	0.5cm,
    framextopmargin		=	3pt,
    framexbottommargin	=	3pt,
    framexleftmargin	=	0.4cm,
    framesep			=	0pt,
    rulesep				=	.4pt,
    backgroundcolor		=	\color{gray97},
    rulesepcolor		=	\color{black},
    %
    stringstyle			=	\color{red},
    showstringspaces	=	false,
    basicstyle			=	\ttfamily\small,
    commentstyle		=	\color{green},
    morecomment         =   [s][\color{blue}]{/*}{*/},
    keywordstyle		=	\color{purple}\bfseries,
    tabsize					=	3,
    %
    numbers				=	left,
    numbersep			=	15pt,
    numberstyle			=	\tiny,
    numberfirstline		=	false,
    breaklines			=	true,
}

\title{Apache Torque}
\author{
	Francisco J. Serrano\\
	Benjamín Fernández\\
	Juan María Frías\\
	David Doñas\\
	Enrique Ríos
}

\begin{document}

% Portada
\begin{titlepage}
	\maketitle
\end{titlepage}

% Indice generado
\tableofcontents
\newpage

\section{Introducción}
	\subsection{Fundación Apache}
		\input{inc/introduccion.fundacion-apache}

	\subsection{Apache Torque}
		\input{inc/introduccion.apache-torque}

\section{Gestores de bases de datos}

	\subsection{Postgresql}
		\input{inc/dbms.postgresql}

	\subsection{MySQL}
		\input{inc/dbms.mysql}
	
	\subsection{SQL Server}
		\input{inc/dbms.sqlserver}

\section{Instalando y configurando Apache Torque con Postgresql}
	\input{inc/ic-postgresql}

	\subsection{Instalando Ant}
		\input{inc/ic-postgresql.instalar-ant}

	\subsection{Creando un proyecto}
		\input{inc/ic-postgresql.crear-proyecto}

	\subsection{Configurando y ejecutando Generator}
		\input{inc/ic-postgresql.configurar-ejecutar-generator}
Accedemos a la carpeta {\bf torque-gen-3.3} de nuestro proyecto.

Descargamos el driver JDBC de la base de datos que queremos utilizar, en nuestro caso Postgresql, desde la siguiente dirección: http://jdbc.postgresql.org/ y lo introducimos en la carpeta “lib” de Generator.

En Postgresql, creamos un usuario “user1” con contraseña “user1” y una base de datos llamada “coches”, de la que es propietario “user1”.

Creamos un directorio en la raíz del proyecto llamado “schema”, donde introduciremos el archivo xml en el cual se describe la base de datos.

Editamos el archivo “build.propierties” añadiendo la configuración de nuestro proyecto. En amarillo se encuentran las líneas que han sido modificadas con respecto al archivo de configuración por defecto.

\subsubsection{build.propierties}
\input{code/build.propierties}

Ahora creamos un archivo XML llamado "coches-schema.xml", en el directorio "schema", donde describiremos la estructura de la base de datos de nuestro sistema. (En este ejemplo solo se usará una tabla, más adelante se explicará las diferentes configuraciones de este fichero)

subsubsection{coches-schema.xml}
\input{code/coches-schema}

Desde cmd.exe accedemos al directorio “torque-gen-3.3” y ejecutamos las siguientes instrucciones: 
Esta instrucción genera los archivos .java y .sql en la carpeta que hemos indicado antes en nuestro archivo “build.propierties”, en nuestro caso en “src”: ant -f build-torque.xml 
La siguiente crea y configura la base de datos:  ant -f build-torque.xml create-db.
Por último esta instrucción crea las tablas en la base de datos, ejecutando el .sql creado con anterioridad: ant -f build-torque.xml insert-sql

Ya tenemos en la carpeta “src” 2 subcarpetas, una llamada “java” donde se encuentran los fuentes de nuestro proyecto y otra llamada “sql”, donde se encuentran los scripts de generación de la base de datos. Movemos la carpeta sql a la raíz del proyecto, ya que no la necesitaremos. Finalmente movemos el contenido del directorio “java” al directorio “src” y eliminamos el directorio “java”. Ya tenemos el proyecto preparado, para seguir trabajando desde Eclipse.

\subsection{Configuración del proyecto desde Eclipse}
Como podemos observar existen numerosos errores en nuestro proyecto, ello es debido a la falta de las librerías de Torque y Village. Las añadimos desde las siguientes direcciones:

\begin{lstlisting}
coches\torque-3.3\lib
\end{lstlisting}

	\begin{center}
		\includegraphics[height=8cm]{img/torque-lib.png}
	\end{center}
	
\begin{lstlisting}
coches\torque-3.3\
\end{lstlisting}

	\begin{center}
		\includegraphics{img/torque-file.png}
	\end{center}
	
	Ahora ya no existen errores en el proyecto y podemos realizar una pequeña prueba de ejecución, para ello podemos crear un paquete, donde crearemos una clase Main e introduciremos el siguiente código:
	
	\input{code/java-test}
	
	Desde nuestro main debemos de inicializar Torque, para ello hemos insertado la línea de código: Torque.init("Torque.properties"). Toque.init toma como parámetro un fichero llamado Torque.properties, situado en la carpeta “torque-3.3”. Movemos ese archivo a la raíz del proyecto (para que sea accesible directamente), y procedemos a configurarlo. En amarillo se encuentran las líneas que han sido modificadas con respecto al archivo de configuración por defecto.
	
	\input{code/torque.properties}
	
	Como último paso añadimos el driver de la base de datos a nuestro proyecto en Eclipse, situado en:
	
\begin{lstlisting}
coches\torque-gen-3.3\lib
\end{lstlisting}

	\begin{center}
		\includegraphics{img/postgresql-file.png}
	\end{center}

	Ya finalmente podemos ejecutar el proyecto, la salida por pantalla sería la siguiente: 
	
	\begin{lstlisting}
	coche_id: 3
	nombre:  mondeo

	coche_id: 4
	nombre:  jumpy
	\end{lstlisting}
	
\section{Instalando y cofigurando Apache Torque con MySQL}
La instalación bajo MySQL es muy parecida a la de Postgresql. A continuación se detallan los cambios y diferencias respecto a la instalación sobre Postgresql.

\subsection{Configuración y ejecución de Generator}
El driver JDBC de la base de datos que descargamos en esta ocasión es para MySQL, desde la siguiente dirección: \url{http://dev.mysql.com/downloads/connector/j/} y lo introducimos en la carpeta “lib” de Generator.

En la edición del archivo build.propierties, se realizan las siguientes modificaciones:
\input{code/build.propierties-mysql}

\subsection{Configuración del proyecto desde eclipse}
Las propiedades del archivo Torque.properties son como siguen para MySQL:

\input{code/torque.properties-mysql}

En este caso, en driver que hay que añadir a nuestro proyecto eclipse es el siguiente:
\begin{lstlisting}
coches\orque-gen-3.3\lib
\end{lstlisting}

\begin{center}
	\includegraphics{img/mysql-file.png}
\end{center}

\section{Instalando y cofigurando Apache Torque con Microsoft SQL Server}
Para la instalación con MS SQL Server habrá que crear un nuevo usuario, o dar permisos a uno ya existente para el acceso a la base de datos que estemos utilizando. Este usuario debe tener la autenticación de SQL Server y el rol db\_ owner. Hay varios drivers disponibles para este tipo de base de datos, como jTDS y uno propio de MS SQL Server disponible desde su página de descargas. En esta guía explicaremos como utilizar jTDS.

\subsection{Configuración y ejecución de Generator}
En la edición del archivo build.propierties, se realizan las siguientes modificaciones:

\input{code/build.propierties-sqlserver}

\subsection{Configuración del proyecto desde eclipse}
Las propiedades del archivo Torque.properties son de la siguiente forma en MS SQL Server:
\input{code/torque.properties-sqlserver}

Por último se añade el driver de la base de datos a nuestro proyecto en Eclipse, situado en:
\begin{lstlisting}
coches\torque-gen-3.3\lib
\end{lstlisting}

%Falta imagen del conector java

Notas acerca el archivo de esquema XML:

Hay que tener cuidado con el uso de palabras clave de MS SQL en tablas y columnas. 
MS SQL admite poner el atributo defaultIdMethod = “native” para generar los campos automáticamente.

\section{Configuración del archivo schema.xml}
\begin{center}
	\includegraphics[height=8cm]{img/xml-config.png}
\end{center}
	
	El esquema de base de datos de torque describe los elementos y atributos de la propia base de datos que estemos utillizando. A continuación se describe los principales elementos y las bases de datos compatibles actualmente.

\subsection{Elemento Database}
Puede contener los siguientes 8 atributos:

name: el nombre de la base de datos.
defaultIdMethod: este se aplica a aquellas tablas que no tienen un atributo id definido. Por defecto es “none”. Normalmente se utiliza si no quieres ID’s generados.
defaultJavaType: tipo predeterminado de las columnas de la base de datos ( “object” o “primitive”, por defecto es primitive).
package: paquete base donde se generará los modelos de objetos asociados con la base de datos. Este reemplaza la propiedad “targetPackage” del archivo build.properties de Torque.
baseClass: la clase base que se utilizará al generar el modelo de objetos.
basePeer: la clase peer a utilizar al generar los pares del modelo de objetos.
defaultJavaNamingMethod: este atributo determina como se convierten los nombres de las tablas y columnas en una clase Java o el nombre del método. Puede tener 3 valores diferentes:
nochange: no se realizan cambios.
underscore: se elimina el subrayado, la primera letra y después de un guión se pone la letra en mayúscula, el resto de caracteres en minúscula.
javaname: con guiones bajos, pero las letras no se convierten en minúscula.
heavyIndexing: agrega indices adicionales para columnas con varias claves primarias.

\subsubsection{External-schema}
Incluye otro archivo de esquema. Puede haber 0 o más elementos de este tipo.

<Externa del esquema
           		filename = "extext-schema.xml" />

\subsubsection{Domain}
Se utiliza para definir los atributos de las columnas.Puede haber 0 o más elementos de este tipo. 

<domain
           name="amount"
           type="NUMERIC"
           size="10"
           scale="2"
           default="0"
           description="amount domain" />

\subsubsection{Table}
Elemento: table
Define las tablas y sus atributos:

\begin{lstlisting}[language=XML]
<table
	name="MY_TABLE"
	javaName="table"
	idMethod="idbroker"
	skipSql="false"
	baseClass="com.myapp.om.table.BaseClass"
	basePeer="com.myapp.om.table.BasePeer"
	javaNamingMethod="underscore"
	description="Table for Torque tests">

	<!-- column information here -->

</table>
\end{lstlisting}

El elemento table tiene los siguientes atributos asociados.

name: el nombre de la tabla que está siendo referenciada.
javaName: como se llamará esta tabla en Java.
idMethod: como s e crearán las claves primarias. Por defecto es nulo.
skipSql: valor booleano (true o false) que indica si hacer o no la generación de SQL para esta referencia.
abstract: valor booleano para generar la clase como abstracta o no.
baseClass: usado para la generación de OM Peer
basePeer: usado para la generación de OM Peer.
alias: define un alias para la tabla.
interface: especifica una interfaz que debería ser referenciada en la sección “implements” de la clase generada.
javaNamingMethod: especifica el nombre de la clase Java del correspondiente objeto OM. Este atributo reemplaza al atributo “defaultJavaNamingMehtod” del elemento de la base de datos (database).
description: se utiliza para la generación de documentación.

El elemento “table” también puede contener los siguientes elementos:

\paragraph{Column}
Puede haber 1 o más elementos de este tipo por tabla.

\begin{lstlisting}
<column
           		name="MY_COLUMN"
           		javaName="Column"
           		primaryKey="true"
           		required="true"
           		size="4"
           		type="VARCHAR"
           		javaNamingMethod="underscore">

           		<!-- inheritance info if necessary -->
</column>
\end{lstlisting}

Contiene los siguientes atributos:
name: nombre de la columna que está siendo referenciada.
javaName: como se llamará esta columna en Java.
primaryKey: valor booleano que indica si es la clave primaria o no. (true o false)
required: indica si el valor es requerido.(true o false, por defecto es false)
type: de que tipo es la columna.
javaType: el tipo de la columna en Java.
size: cuantos carácteres o digitos van a ser almacenados.
default: valor por defecto si al insertar está vacio.
autoIncrement: si este campo tiene autoincremento no. (true o false, por defecto es false)
inheritance. Indica si tiene herencia. Puede tomar los valores “single” o “false”.

javaNamingMethod: especifica el nombre que será utilizado en la clase Java del correspondiente objeto OM. Este atributo reemplaza al atributo “defaultJavaNamingMehtod” del elemento de la base de datos (database).

description: se utiliza para la generación de documentación.

\paragraph{Foreing-key}
Puede haber 0 o más elementos de este tipo por tabla.

\begin{lstlisting}
<foreign-key foreignTable="MY_TABLE"
	name="MY_TABLE_FK"
	onUpdate="none"
	onDelete="none">
	
	<!-- reference info -->
	<reference
	local="[columna_local]"
	foreign="[columna_foreign]"/>
</foreign-key>
\end{lstlisting}

Este elemento tiene 4 atributos:
foreignTable: el nombre de la tabla donde se encuentra la clave foránea.
name: el nombre de la clave foránea.
onUpdate: acción a realizar cuando se actualiza el valor en foreignTable.
onDelete: acción a realizar cuando se elimina el valor en foreingTable.

\paragraph{Index}
Puede haber 0 o más elementos de este tipo por tabla.

\begin{lstlisting}
<index name="MY_INDEX">
	<!-- index-column info -->
</index>
\end{lstlisting}

El elemento index tiene 1 atributo asociado:
name: el nombre del índice. 
Puede contener 1 o más elementos  del tipo:

\subparagraph{Index-column}
\begin{lstlisting}
<index-column name="INDEX_COLUMN"/>
\end{lstlisting}

Tiene solo un atributo: “name” que indica el nombre del índice de la columna. Este elemento no puede contener otros elementos.

\section{Funcionamiento de las clases generadas}
\subsection{Usando el objeto}
Torque genera cuatro clases por cada tabla. Por ejemplo en la aplicación coche nos aparecen las siguientes clases:
BaseCoche.java: Es donde Torque genera toda la lógica necesaria para la clase coche.

Coche.java: Esta clase extiende de BaseCoche.java, Torque nos proporciona esta clase vacía, para que en el caso de que necesitemos añadir nuevos métodos a Coche, lo hagamos en ella.

BaseCochePeer.java: En esta clase Torque nos proporciona métodos estáticos para el uso de la base de datos.

CochePeer.java: Al igual que en Coche.java esta clase extiende de BaseCochePeer.java y Torque nos la genera vacía para que añadamos nuestros propios métodos estáticos.

\subsection{Insertando filas}

Para añadir una nueva fila en la tabla “Publisher”, existen dos formas de hacerlo. Una es utilizando la clase estática generada “xPeer” (siendo ‘x’ el nombre de la tabla), y otra mediante objetos con el nombre propio de la tabla.

Para insertar una nueva fila mediante objetos, en primer lugar debemos de crear un objeto de la tabla que vamos a modificar/insertar datos.

Publisher addison = new Publisher();

A continuación rellenamos los atributos del objeto, que son los mismos que las columnas de la tabla.

addison.setName("Addison Wesley Professional");

Finalmente, para guardar los datos del objeto en la base de datos, llamamos al método “save()”.

addison.save();

\subsection{Usando la clase estática}
Creamos un objeto de la tabla.

Author stevens = new Author();

Se rellenan los campos.

stevens.setFirstName("W.");
stevens.setLastName("Stevens");

Usamos la clase estática en este caso llamada “AuthorPeer”, para insertar el nuevo registro en la base de datos

AuthorPeer.doInsert(stevens);


\subsection{Seleccionando filas}
La clase generada “Criteria” es la equivalente al ‘where’ de sql. Para una consulta tendremos que generar siempre un objeto Criteria, en caso de que la consulta no incluya un tipo ‘where’, simplemente se crea el objeto Criteria y no se modifica ningún atributo.

Criteria crit = new Criteria();

La clase estática “xPeer” contiene métodos para la manipulación de la base de datos, como por ejemplo usaremos una consulta de selección

List books = BookPeer.doSelect(crit);

Si queremos añadir alguna condición where, simplemente utilizamos el método “add”. Dicho método tiene gran variedad de cabeceras para los distintos tipos de condiciones (group by, like....). En este caso, ponemos como condición la igualdad:

Criteria crit = new Criteria();
crit.add(BookPeer.ISBN, "0-618-12902-2");
List books = BookPeer.doSelect(crit);

Otro ejemplo, para una comparación “mayor que”

\begin{lstlisting}
crit.add(CochePeer.COCHE_ID, 2, Criteria.GREATER_THAN);
\end{lstlisting}

\subsection{Actualizando filas} 

Para la actualización de filas, se puede utilizar el método ‘doUpdate’ de la clase estática ‘xPeer’:

effective.setAuthor(stevens);
effective.save();
tcpip.setAuthor(bloch);
BookPeer.doUpdate(tcpip);

\subsection{Eliminando filas}

Para eliminar filas, se utiliza el método ‘doDelete’ de ‘xPeer’

crit = new Criteria();
crit.add(BookPeer.ISBN, "0-618-12902-2");
BookPeer.doDelete(crit);

crit = new Criteria();
crit.add(BookPeer.ISBN, "0-201-63346-9");
crit.add(BookPeer.TITLE, "TCP/IP Illustrated, Volume 1");
BookPeer.doDelete(crit);

%Estudiar datadump
En el ant, en la última sentencia, se añade “datadump” 
‘ant -f build-torque.xml datadump’

\section{Aplicacion}
\subsection{Esquema base datos}
\input{code/notas-schema}

\end{document}
